name: FastAPI Application CI/CD

on:
  push:
    branches: [ main, develop ]
    paths-ignore:
      - 'terraform/**'
      - '.github/workflows/infrastructure.yml'
  pull_request:
    branches: [ main ]
    paths-ignore:
      - 'terraform/**'
      - '.github/workflows/infrastructure.yml'

env:
  APP_NAME: fastapi-app
  REGISTRY_NAME: srechallengedevacr  # Update based on your environment
  NAMESPACE: fastapi-app

jobs:
  test:
    runs-on: ubuntu-latest
    name: Test Application
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Run linting
      run: |
        pip install flake8 black isort
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        black --check .
        isort --check-only .
        
    - name: Run tests
      run: |
        pytest test_main.py -v --tb=short
        
    # - name: Run security scan
    #   run: |
    #     pip install bandit safety
    #     bandit -r . -x ./test_*.py
    #     safety check
    # continue-on-error: true

  build:
    runs-on: ubuntu-latest
    needs: test
    name: Build Container Image
    if: github.ref == 'refs/heads/main'
    
    outputs:
      image_tag: ${{ steps.image_tag.outputs.tag }}
      image_name: ${{ steps.image_tag.outputs.image }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Generate image tag
      id: image_tag
      run: |
        TAG="v$(date +%Y%m%d)-${GITHUB_SHA:0:7}"
        IMAGE="${{ env.REGISTRY_NAME }}.azurecr.io/${{ env.APP_NAME }}:${TAG}"
        echo "tag=${TAG}" >> $GITHUB_OUTPUT
        echo "image=${IMAGE}" >> $GITHUB_OUTPUT
        echo "Generated image: ${IMAGE}"

    - name: Log in to Azure Container Registry
      uses: azure/docker-login@v2
      with:
        login-server: ${{ env.REGISTRY_NAME }}.azurecr.io
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}
    
    - name: Build and push container image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          ${{ steps.image_tag.outputs.image }}
          ${{ env.REGISTRY_NAME }}.azurecr.io/${{ env.APP_NAME }}:latest
        
    - name: Container security scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ steps.image_tag.outputs.image }}
        format: 'sarif'
        output: 'trivy-results.sarif'
        
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  deploy:
    runs-on: ubuntu-latest
    needs: build
    name: Deploy to AKS
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Azure Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'
    
    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group sre-challenge-dev-rg \
          --name sre-challenge-dev-aks
    
    - name: Create namespace
      run: |
        kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
    
    - name: Create DB password secret
      run: |
        kubectl create secret generic db-password \
          --namespace ${{ env.NAMESPACE }} \
          --from-literal=DB_PASSWORD=${{ secrets.DB_PASSWORD }} \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy with Helm
      run: |
        # Get ingress IP for dynamic host configuration
        INGRESS_IP=$(kubectl get svc nginx-ingress-ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "pending")
        
        helm upgrade --install ${{ env.APP_NAME }} helm/fastapi-app \
          --namespace ${{ env.NAMESPACE }} \
          --set image.repository=${{ env.REGISTRY_NAME }}.azurecr.io/${{ env.APP_NAME }} \
          --set image.tag=${{ needs.build.outputs.image_tag }} \
          --set ingress.hosts[0].host=${{ env.APP_NAME }}.${INGRESS_IP}.nip.io \
          --wait --timeout=5m
        
    - name: Verify deployment
      run: |
        # Wait for pods to be ready
        kubectl wait --for=condition=available --timeout=300s deployment/${{ env.APP_NAME }} -n ${{ env.NAMESPACE }}
        
        # Get pod status
        kubectl get pods -n ${{ env.NAMESPACE }} -l app.kubernetes.io/name=${{ env.APP_NAME }}
        
        # Get ingress info
        kubectl get ingress -n ${{ env.NAMESPACE }}
        
        # Test application endpoints
        INGRESS_IP=$(kubectl get svc nginx-ingress-ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        if [ ! -z "$INGRESS_IP" ] && [ "$INGRESS_IP" != "pending" ]; then
          APP_URL="http://${{ env.APP_NAME }}.${INGRESS_IP}.nip.io"
          echo "Testing application at: $APP_URL"
          
          # Wait a bit for ingress to be ready
          sleep 30
          
          # Test endpoints
          curl -f -s "$APP_URL/" || echo "Root endpoint not ready yet"
          curl -f -s "$APP_URL/health" || echo "Health endpoint not ready yet"
          
          echo "Application deployed successfully!"
          echo "URL: $APP_URL"
        else
          echo "Ingress IP not ready yet, but deployment completed"
        fi

  notify:
    runs-on: ubuntu-latest
    needs: [test, build, deploy]
    if: always()
    name: Notify Deployment Status
    
    steps:
    - name: Notify success
      if: ${{ needs.deploy.result == 'success' }}
      run: |
        echo "üéâ FastAPI application deployment successful!"
        
    - name: Notify failure
      if: ${{ needs.deploy.result == 'failure' || needs.build.result == 'failure' || needs.test.result == 'failure' }}
      run: |
        echo "‚ùå FastAPI application deployment failed!"

  integration-test:
    runs-on: ubuntu-latest
    needs: deploy
    name: Integration Test (Live API)
    if: github.ref == 'refs/heads/main'
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install requests

    - name: Wait for app to be ready
      run: sleep 30

    - name: Run integration tests
      env:
        BASE_URL: http://${{ env.APP_NAME }}.${{ env.NAMESPACE }}.nip.io
      run: |
        pytest test_main.py -v --tb=short